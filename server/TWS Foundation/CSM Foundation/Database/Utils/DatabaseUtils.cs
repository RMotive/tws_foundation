using System.Reflection;
using System.Text.Json;

using CSM_Foundation.Database.Models.Options;
using CSM_Foundation.Server.Enumerators;
using CSM_Foundation.Server.Managers;

namespace CSM_Foundation.Database.Utils;
public class MigrationUtils {
    private const string DirectoryName = ".Connection";
    private const string QualityPrefix = "quality_";
    private const string DevelopmentPrefix = "development_";
    private const string ProductionPrefix = "production_";

    /// <summary>
    ///     Fetches and loads through IO functionallities for private file based secret
    ///     connection properties for DataDatabasess connections handlers. 
    ///     Then build it and validate it to generate a Model.
    ///     
    ///     RECOMMENDED: Check the parameter documentation to ensure the correct use.
    /// </summary>
    /// <param name="cp"> 
    ///     Automatically gets the path of the method caller through execution-time assemblies access
    ///     attribute decorator, this is correctly calculated when the method is called
    ///     directly in the DataDatabases context class that is generated by the EF CLI tools when 
    ///     migrated a database configuration, otherwise can struggle with the correct project 
    ///     file leveling generation. 
    ///     In that kind of cases this parameter can be overwritten by the caller to inject
    ///     the correct dataDatabases project root path.
    /// </param>
    /// <returns>
    ///     <see cref="DataDatabasesConnectionModel"/>: The dataDatabases connection properties gathered and retrieved from the found private properties file.
    /// </returns>
    /// <exception cref="XDataDatabasesConnectionLoad">
    ///     When something gone wrong during the IO connection properties gather operation.
    /// </exception>
    public static DatabasesLinkOptions Retrieve(string DatabaseSign) {
        string wd = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;

        string prefix = EnvironmentManager.Mode switch {
            ServerEnvironments.development => DevelopmentPrefix,
            ServerEnvironments.quality => QualityPrefix,
            ServerEnvironments.production => ProductionPrefix,
            _ => DevelopmentPrefix,
        };
        string fn = $"{prefix}connection.json";

        if (wd is null) {
            throw new ArgumentNullException(wd);
        }
        
        string tp = $"{wd}\\{DatabaseSign.ToUpper()}{DirectoryName}";
        string? cpd = Directory.GetDirectories(wd)
            .Where(i => i == tp)
            .FirstOrDefault()
            ?? throw new DirectoryNotFoundException($"{tp} not found in the system");
        
        string tfn = $"{tp}\\{fn}";

        string[] cfs = Directory.GetFiles(cpd);
        string cpfi = cfs
            .Where(i => i == tfn)
            .FirstOrDefault()
            ?? throw new FileNotFoundException();

        using FileStream pfs = new(cpfi, FileMode.Open, FileAccess.Read, FileShare.Read);
        DatabasesLinkOptions? m = JsonSerializer.Deserialize<DatabasesLinkOptions>(pfs);
        pfs.Dispose();

        return m is null ? throw new Exception() : m;
    }
}
